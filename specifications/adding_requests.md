This section explains the process of how to implement your own requests to CurryInfo. As the whole program is implemented using Curry, your additions also need to be implemented in Curry as you need to edit the existing code.

Each request returns a piece of information about an object of a Curry Package and also saves this in a json file on the local machine. The objects are Package, Version, Module, Type, Typeclass and Operation. Each object has its own type with the names needed to find the exact object. For example a Module object would have three strings, one being the name of the package, another being the version number and the last being the name of the module itself.

When you wish to ass your own request, you have to register it in CurryInfo.Configuration. For every type of object there is its own configuration in the form of a list. To register a new request, you will need to implement 4 operations and define 2 strings. These will use type variable to allow you to define them for different combinations of types. 'a' is the object type (i.e. CurryPackage for Package or CurryType for Type) and 'b' is the result type of your request.

The strings are the name and the description of the request. The name is used as argument when running the tool like you would do with any other request. The description is the explanation shown to the user if they run the tool with the help option.

Next you will start implementing the operations. The first is the most important one, as it will generate the information you want to be returned by your request. Its type is 'Options -> a -> IO (Maybe b)'. The 'Options' type allows you to access the options with which the user runs the tool, making it possible to print specific messages depending on the verbosity level for example. As the generating of the information may fail and as it might need to access the outside world like the file system, the result is encapsulated in 'IO' and 'Maybe'.

After that you will need to implement 2 linked operations, one converting the result into a json value and the other doing the reverse converting a json value into the result type. You need to make sure that both these operations match each other, as the first is used to write the result into a json file and the second is used to read that result from the same json file instead of needing to generate it every time.

The first is of type 'b -> JValue'. There are some helper functions making it easier to implement this operation like 'jrMap' allowing you to convert a list into a json array and 'jrRead' allowing you to implicitly use the Read instance of your result, if it has one.

The second operation is of type 'JValue -> Maybe b'. You can see, that it basically reverts the previous operation with the only difference being that its result is encapsulated in 'Maybe' to avert possible crashes because of bugs in the operations. Just as before there are some helper functions to help in implementing new requests.

Now there is only one operation left to be implemented. Its type is 'Options -> b -> IO String'. As with the operation that generates the result, the 'Options' type allows you to print messages to inform the user of the progress. The operation is used to create the string that is shown to the user as result at the end as output. The reason, for why it needs its own operation for that, is because the result might not contain the actual information the user wants, instead only referencing it in some form. There are some requests that store the result as references to a section of a file instead of storing the section directly. In this case the printing operation needs to extract that section and present it to the user. And because of that does the operation live in the 'IO' space, as it might need to access the outside world like specific files.

With the operations implemented, the last thing you need to do is register your request. Go into the corresponding configuration (i.e. versionConfiguration for Version or typeclassConfiguration for Typeclass) and use the operation 'registerRequest'. It takes the 2 strings and the 4 operations as input in this order: name, description, generating operation, json reading operation, json writing operation, printing operation. When you have done that, you need to recompile the tool. After that, to make sure your request is correctly registered, you can run the tool with the help option and see that your request is in the correct list with its name and description. You should now be able to run the tool with your new request.